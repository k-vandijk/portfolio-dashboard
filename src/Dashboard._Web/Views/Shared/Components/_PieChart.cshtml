@model Dashboard.Web.ViewModels.PieChartViewModel
@{
    var chartId = (string?)ViewData["ChartId"] ?? "chart_" + Guid.NewGuid().ToString("N");
}

<div class="card">
    @if (!string.IsNullOrEmpty(Model.Title))
    {
        <div class="card-header">@Model.Title</div>
    }
    <div class="card-body">
        <canvas id="@chartId" class="chart-canvas"></canvas>
    </div>
</div>

<script>
    $(document).ready(function() {
        var element = document.getElementById('@chartId');
        if (!element) return;

        // Chart data serializeren
        const chartData = @Html.Raw(JsonSerializer.Serialize(new {
            labels = Model.Data.Select(dp => dp.Label),
            datasets = new[] {
                new {
                    data = Model.Data.Select(dp => dp.Value),
                    borderWidth = 3,
                    hoverOffset = 3
                }
            }
        }));

        const total = chartData.datasets[0].data.reduce((a, b) => a + b, 0);

        // Css variables ophalen
        chartData.datasets[0].backgroundColor = accentColors;
        chartData.datasets[0].hoverBackgroundColor = accentColors.map(c => lightenColor(c, 0.05));

        const yFormat = @Html.Raw(JsonSerializer.Serialize(Model.Format)); // "currency" | "percentage" | "number"
        const fmtCurrency = new Intl.NumberFormat('nl-NL', { style: 'currency', currency: 'EUR', minimumFractionDigits: 2, maximumFractionDigits: 2 });
        const fmtNumber = new Intl.NumberFormat('nl-NL', { maximumFractionDigits: 2 });

        var chart = new Chart(element, {
            type: 'pie',
            data: chartData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { 
                    legend: { 
                        position: 'bottom', 
                        onClick: null
                    },
                    tooltip: {
                        callbacks: {
                            label: (ctx) => {
                                const value = ctx.parsed;
                                const pct = total > 0 ? (value / total * 100) : 0;
                                return `${formatY(value)} (${fmtNumber.format(pct)}%)`;
                            }
                        }
                    }
                },
                onClick: (evt) => {
                    const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                    if (!points.length) return;

                    const sliceIndex = points[0].index;
                    const clickedTicker = String(chart.data.labels[sliceIndex]);

                    // Als de parent layout een functie 'onSelectTicker' heeft:
                    if (typeof window.onSelectTicker === 'function') {
                        window.onSelectTicker(clickedTicker);
                    }
                },
                onHover: (evt, activeEls) => {

                    // Als de parent layout een functie 'onSelectTicker' heeft:
                    if (typeof window.onSelectTicker === 'function') {
                        evt.native.target.style.cursor = activeEls.length ? 'pointer' : 'default';
                    }
                },
            }
        });
    });

    function formatY(v) {
        if (yFormat === 'currency') return fmtCurrency.format(v);
        if (yFormat === 'percentage') return fmtNumber.format(v) + '%';
        return fmtNumber.format(v);
    }

    function lightenColor(color, percent) {
        // works with rgb/rgba or hex
        let num = parseInt(color.replace("#",""),16),
            amt = Math.round(2.55 * (percent * 100)),
            R = (num >> 16) + amt,
            G = (num >> 8 & 0x00FF) + amt,
            B = (num & 0x0000FF) + amt;
        return "#" + (
            0x1000000 +
            (R<255?R<1?0:R:255)*0x10000 +
            (G<255?G<1?0:G:255)*0x100 +
            (B<255?B<1?0:G:255)
        ).toString(16).slice(1);
    }

</script>